# Reference: https://pythontic.com/modules/socket/bind
# Reference: https://stackoverflow.com/questions/45498916/how-to-retrieve-a-python-logging-log-record-over-a-socket

import sys
import socket
import time
from threading import Thread
import csv

logger_args_num = 1  # define the number of args that node should receive

'''Function receive_message_tcp'''
'''
Description:
Use Pyton Socket to establish TCP link; The local logger could receive message of events from the centrolized node by tcp
Input: ip address, port
Ouput: None
Side effect: messages received from the server node and be show on the local machine
             new thread start by listening from the client
'''
def receive_message_tcp(addr, port):
    s = socket.socket()
    # TCP connected: Since we may use socket that needs to be made a server socket. we can use s.bind()
    # s.connect((addr,port))
    clientAddress = addr
    s.bind((clientAddress, port))
    s.listen()
    
    # Receive the messages\events by the server node with TCP transimission
    # keep waiting from the client for new thread to start 
    while True:
        (clientSocket, clientAddress) = s.accept();
        print("The log file shows as follow:")
        # print("Start waiting for new thread\n")
        new_event=Thread(target=Makelog,args=(clientSocket,))
        new_event.start()
        # print("End of a new thread\n")

    
    print("-------------Successfully Received messages---------------\n")
    # TCP disconnected
    s.close()

'''Function Makelog'''
'''
Description:
Use Pyton Socket to establish TCP link; The network node could send the message of events generated by the local generator.py program (stdin)
to the centralized node by tcp
Input: socket s
Ouput: None
Side effect: messages received from the server node and be show on the local machine
             received data could be stored as the local csv file
'''
def Makelog(s):
    receive_status = 1 # set the flag for the receiving status 
    while (receive_status):
        recv_data = s.recv(128).decode("utf-8")
        if len(recv_data) != 0:
            for item in recv_data:
                print(recv_data)
                recv_item = item.split(" ")
                
                # Data received to calculate the bandwidth
                if len(recv_item)==3:
                    NodeName= recv_item[1]
                    genr_time=float(recv_item[0])
                    recv_time=time.time()
                    delay=(recv_time-genr_time)*1000 
                    bandwidth=len(recv_data)/delay
                    csv_data=[NodeName,delay,bandwidth]                    
                    w.writerow(csv_data) # Write on csv    
              
        receive_status = 0 # the receiveing transmission procedure is finished


def main(argv=None):
    if argv is None:
        argv = sys.argv

    # Exit from the main func if not correct number of args are input by the command window    
    if len(argv)-1 != logger_args_num :
        print("----------Logger Args Error Occured!----------\n")
        print("The args input taken for logger.py should be the form as: <node name> <IP address> <port number>\n")
        sys.exit(1)
    
    port = int(argv[1]) # Port Number
    addr = "127.0.0.1" # Set the local ip addr as the server

    # argv[0] is the name of program
    receive_message_tcp(addr, port)

if __name__ == "__main__":
    with open("messages.csv",mode="w") as file:
        w=csv.writer(file)
        h=['NodeName','delay[sec]','bandwidth[bytes per sec]']
        w.writerow(h)
        main()



